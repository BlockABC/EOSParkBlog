

# EOSPark杂谈：RAM——扩容



<p align="right">作者：specer</p>

<p align="right">联系邮箱：specer@eospark.com</p>

<p align="right">日期：2018.8.13</p>



RAM扩容方案已经实施了大半个月了，那段时间团队的事情比较多，没有什么精力去研究RAM的扩容方案。不过最近进来了很多优秀的新同学，我也终于能腾出点时间来修正一下之前首页中[关于RAM](https://eospark.com/ram.html)的过期文章了。

扩容方案出来后，在那篇文章里提到的部分公式/结论已经失效，这里一一梳理下。



## 代码的改动

1. RAM扩容的细节可以看[官方源码](https://github.com/EOSIO/eosio.contracts/blob/master/eosio.system/src/eosio.system.cpp#L79)，总结起来就是今后每出一个块新增1KB的RAM到可用RAM池子里。
2. RAM兑换公式里修正了[指数](https://github.com/EOSIO/eosio.contracts/blob/master/eosio.system/src/exchange_state.cpp#L8)的错误。不过这个修复也无伤大雅，因为可以看到通过[之前文章](https://eospark.com/ram.html)里所写的推导过程，这个指数实际上最后会被约掉。新的代码依旧没有严格按照[bancor算法白皮书](https://about.bancor.network/protocol/)里写的公式来实现。其实这个也无关紧要，因为EOS并没有用到bancor算法的精华，仅仅是用来当作一个中间货币而已，其实本质上跟bancor没有任何关系。



​	bancor白皮书第11页末尾里描述的公式为：

<img :src="$withBase('/projects/ram2-1.png')">

​	EOS源码里实现的是：

<img :src="$withBase('/projects/ram2-2.png')">

对比可以知道，区别在于分母这里，bancor原始算法是用的更新前的值参与兑换，兑换完成后再更新值。而EOS的实现是先更新值，然后再代入到兑换公式里参与计算。



## 对之前结论的影响

尽管修正了指数，但是单位EOS兑换多少RAM的公式__依旧生效__，因为上面说了推导过程中这个指数会被约掉，感兴趣的同学可以自己去试试。


$UnitEOSforRAM=\frac{C}{1+B}=\frac{C}{B}$


同理单位RAM兑换多少EOS的公式也有效：


$UnitRAMforEOS=\frac{B}{1+C}=\frac{B}{C}$


大家可以从现在的数据验证上面两个公式的正确性。



由于扩容方案的影响，之前得到的那个比较有趣的结论已经失效了：

<center><del><h4>无论RAM市场如何波动，B和C的乘积是几乎保持不变的。</h4></del></center>



那么现在的B和C之积是什么呢，我尝试推导了一下。

还是以买入RAM为例，B、C变化情况为：

 $B_1 = B_0 + X_0$ 


 $C_1 = C_0 - RAM+c_1 = \frac{B_0C_0}{X_0+B_0}+c_1$ 



$c_1$为这期间增发的RAM容量。继续：


 $B_1C_1 = B_0C_0+B_1c_1$ 


同样的：


$B_2C_2 = B_1C_1+B_2c_2= B_0C_0+B_1c_1+B_2c_2$


即：


$B_nC_n = B_0C_0+B_1c_1+B_2c_2+...+B_nc_n$

以写本篇文章的时刻为例，区块高度为10912132：

```json
{
    "rows": [
        {
            "supply": "10000000000.0000 RAMCORE",
            "base": {
                "balance": "23715712979 RAM",
                "weight": "0.50000000000000000"
            },
            "quote": {
                "balance": "3712787.3588 EOS",
                "weight": "0.50000000000000000"
            }
        }
    ],
    "more": false
}
```

即此时的$B_n=3712787.3588$，$C_n=23715712979/1024=23159875.9560547$。有：

$B_nC_n=3712787.3588*23159875.9560547=85987694681015.95$

据我所知，实施RAM扩容方案时的区块高度大概在7827060左右，那个时候的B和C是：$B_0=4446923$， $C_0=15091077.8928$

考虑到那时有个突然暴增1.5G内存的bug，那么实际的$B_0C_0$应该是：

$B_0C_0=(1.5*1024*1024+15091077.8928)*4446923=74103266473755.86$



那么：

$B_1c_1+B_2c_2+...+B_nc_n=B_nC_n-B_0C_0$

$=85987694681015.95-74103266473755.86=11884428207260.1$

而c为两笔RAM买卖之间增发的RAM容量，所以从$B_0$时刻到$B_n$时刻增发的RAM总容量即为两者的区块高度差乘以每个块增发的RAM，即有：

$c_1+c_2+...+c_n=(10912132-7827060)*1 KiB=3085072 KiB$



本人纯野生数学爱好者，能力有限加上业务繁忙，就先抛砖引玉到这里了，感兴趣的同学可以继续深挖。如果有什么地方说错了的欢迎邮件我指正，如果嫌邮件麻烦，可以关注我们的公众帐号，搜索：`BlockABCTeam`，或者直接扫描[网站底部](https://eospark.com/MainNet)的微信二维码关注。公众帐号的日常会由运营妹纸打理，我也会经常上去看看。

